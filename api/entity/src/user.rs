//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.7

use async_trait::async_trait;
use rquest_core::auth;
use rquest_core::http::{Helpers, Result};
use sea_orm::entity::prelude::*;
use sea_orm::entity::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "user")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    #[sea_orm(column_type = "Text", unique)]
    pub username: String,
    #[sea_orm(column_type = "Text", unique)]
    pub email: String,
    #[sea_orm(column_type = "Text")]
    #[serde(skip_deserializing, skip_serializing)]
    pub password_hash: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub image: Option<String>,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: Option<DateTimeWithTimeZone>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::message::Entity")]
    Message,
}

impl Related<super::message::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Message.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Deserialize)]
pub struct UpdateParams {
    username: Option<String>,
    email: Option<String>,
    image: Option<String>,
}

#[derive(Deserialize)]
pub struct CreateParams {
    username: String,
    email: String,
    password: String,
}

impl Entity {
    pub fn find_by_id(id: Uuid) -> Select<Entity> {
        Self::find().filter(Column::Id.eq(id))
    }
    pub fn find_by_email(email: String) -> Select<Entity> {
        Self::find().filter(Column::Email.eq(email))
    }
}

#[async_trait]
pub trait Query<T> {
    async fn find_by_id(db: &DbConn, id: Uuid) -> Result<T>;
    async fn find_all(db: &DbConn) -> Result<Vec<T>>;
}

#[async_trait]
impl Query<Model> for Entity {
    async fn find_by_id(db: &DbConn, user_id: Uuid) -> Result<Model> {
        Entity::find_by_id(user_id).one_or_nf(db, "user").await
    }
    async fn find_all(db: &DbConn) -> Result<Vec<Model>> {
        Ok(Entity::find().all(db).await?)
    }
}

#[async_trait]
pub trait Mutation<T> {
    async fn create(db: &DbConn, req: CreateParams) -> Result<T>;
    async fn update(db: &DbConn, user_id: Uuid, req: UpdateParams) -> Result<T>;
    async fn update_password(db: &DbConn, user_id: Uuid, password: String) -> Result<T>;
    async fn delete(db: &DbConn, user_id: Uuid) -> Result<()>;
}

#[async_trait]
impl Mutation<Model> for Entity {
    async fn create(db: &DbConn, req: CreateParams) -> Result<Model> {
        let user = ActiveModel {
            username: ActiveValue::Set(req.username),
            email: ActiveValue::Set(req.email),
            password_hash: ActiveValue::Set(auth::hash_password(req.password).await?),
            ..Default::default()
        }
        .insert(db)
        .await?;

        Ok(user)
    }
    async fn update(db: &DbConn, user_id: Uuid, req: UpdateParams) -> Result<Model> {
        let user = <Entity as Query<Model>>::find_by_id(db, user_id).await?;

        let res = ActiveModel {
            id: ActiveValue::Unchanged(user.id),
            username: match req.username {
                Some(username) => Set(username),
                None => ActiveValue::Unchanged(user.username),
            },
            email: match req.email {
                Some(email) => Set(email),
                None => ActiveValue::Unchanged(user.email),
            },
            image: match req.image {
                Some(image) => Set(Some(image)),
                None => ActiveValue::Unchanged(user.image),
            },
            ..Default::default()
        }
        .update(db)
        .await?;

        Ok(res)
    }
    async fn update_password(db: &DbConn, user_id: Uuid, password: String) -> Result<Model> {
        let user = <Entity as Query<Model>>::find_by_id(db, user_id).await?;

        let res = ActiveModel {
            id: ActiveValue::Unchanged(user.id),
            password_hash: ActiveValue::Set(auth::hash_password(password).await?),
            ..Default::default()
        }
        .update(db)
        .await?;

        Ok(res)
    }
    async fn delete(db: &DbConn, user_id: Uuid) -> Result<()> {
        let user: ActiveModel = <Entity as Query<Model>>::find_by_id(db, user_id)
            .await
            .map(Into::into)?;

        user.delete(db).await?;
        Ok(())
    }
}
